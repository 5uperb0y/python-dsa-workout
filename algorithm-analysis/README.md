# CHAPTER TWO | ALGORITHM ANALYSIS

## Review Questions
- What underlies the efficiency of the append method in lists compared to concatenation?
- Delineate the time complexities of pop() versus pop(i) in lists and the reasons behind their differences.
- In terms of performance, how does using extend to add a single element to a list compare with append?
- Why does list comprehension offer a performance advantage over conventional for-loop constructs when populating lists?
- Elucidate the principle of 'Order of Magnitude' in algorithmic complexity and discuss the limitations of using raw time as an efficiency metric.
- What factors contribute to dictionary indexing being more efficient than list indexing?
- Differentiate between worst-case, best-case, and average-case time complexities in the context of algorithm analysis.
- Discuss the implications and significance of Big O, Big Theta, and Big Omega notations in algorithmic complexity analysis.
- Provide a rationale for the common practice of disregarding constants and lower-order terms in Big O notation.

## Exercises
- [Benchmark custom vs. built-in sum, page 42](./custom-vs-defult-sum.py)
- [Identify minimum in a list, page 47](./min-number-in-a-list.py)
- [Compare anagram determination methods, page 48](./anagram-method-benchmark.py)
- [Compare list creation methods' runtime, page 52](./list-creation-timing.py)
- [Compare list pop operation, page 55](./list-pop-timing.py)
- [Compare contain operator for list vs. dictionary](./list-vs-dict-contains.py)
- [Verify list index operator's constant time](./verify-list-index-constant-time.py)