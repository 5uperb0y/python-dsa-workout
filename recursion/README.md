# CHAPTER FOUR | RECURSION

## Review Questions
- Explain the concept of recursion and provide an example of a recursive solution.
- What are the Three Laws of Recursion, and why are they crucial?
- Describe how stack frames are used in the execution of recursive functions.
- Explain the relationship between fractals and recursion.
- In recursive maze solving, why is a stack used implicitly instead of a queue?
- Why is Depth-First Search preferred in recursive maze solving? Discuss the trade-offs between DFS and BFS.
- Describe a scenario where a recursive solution is more efficient than an iterative one. What makes recursion a better choice in this scenario?

## Exercises
- [Implement list sum with recursion, page 118](./list_sum.py)
- [Implement factorial with recursion, page 121](./factorial.py)
- [Convert an integer to a string in any base, page 121](./base_converter.py)
- [Reverse a string with recursion, page 122](./reverse.py)
- [Check if a string is palindrome, page 122](./is_palindrome.py)
- [Draw a spircal, page 125](./draw_spiral.py)
- [Draw a fractal tree, page 126](./draw_fractal_tree.py)
- [The tower of Hanoi, page 133](./hanoi_tower.py)
- [The tower of Hanoi with disk visualization, page 133](./hanoi_tower_viz.py)
- [Create a maze, page 137](./maze.py)
- [Find a way to exit a maze, page 137](./find_exit.py)
- [Draw a Pascal's triangle, page 146](./pascals_triangle.py)
- [Cross river problem, page 146](./cross_river.py)
- [Pour water problem, page 146](./jugs.py)
